/**
 * Module:	include/installation/rootpart.ycp
 *
 * Authors:	Stefan Schubert <schubi@suse.de>
 *		Arvin Schnell <arvin@suse.de>
 *              Jiri Srain <jsrain@suse.cz>
 *
 * Purpose:	Select root partition for update or booting.
 *		RootPart::rootPartitions must be filled before
 *		calling this module.
 */
{
textdomain "update";

import "Wizard";
import "Popup";
import "Label";
import "RootPart";
import "GetInstArgs";
import "Report";
import "Update";

// Returns boolean whether partition can be
// a Linux 'root' file system
boolean CanBeLinuxRootFS (symbol partition_fs) {
    if (partition_fs == nil) {
	y2error("partition_fs not defined!");
	return false;
    }

    // possible_root_fs contains list of supported FSs
    return contains (RootPart::possible_root_fs, partition_fs);
}

list <term> make_partition_list (boolean withall) {
	list<term> part_list = [];
	foreach (string partition, map i, RootPart::rootPartitions, {
	    // see https://bugzilla.novell.com/attachment.cgi?id=96783&action=view

	    if (i[`valid]:false || withall)
	    {
		// `ext2, `jfs, ...
		symbol part_fs = (symbol) i[`fs]:nil;
		string part_fs_name = tostring (part_fs);
		if (part_fs_name != nil && regexpmatch (part_fs_name, "^`(.*)$")) {
		    part_fs_name = regexpsub (part_fs_name, "^`(.*)$", "\\1");
		}

		string system = i[`name]:"error";
		// unknown system
		if (system == "unknown") {
		    if (part_fs != nil) {
			if (CanBeLinuxRootFS (part_fs)) {
			    // Table item (unknown system)
			    system = _("Unknown Linux");
			} else {
			    // Table item (unknown system)
			    system = _("Unknown or Non-Linux");
			}
		    } else {
			// Table item (unknown system [neither openSUSE 11.1 nor SLES 14 nor ...])
			if (system == "unknown") system = _("Unknown");
		    }
		}

		string arch = i[`arch]:"error";
		// Table item (unknown architecture)
		if (arch == "unknown") arch = _("Unknown");

		// fist, use the name of file system (with short name for Linux)
		// then the file system short name
		// then "Unknown"
		string fs = "";

		// is a linux fs, can be a root fs, has a fs name
		if (part_fs != nil && i[`fstype]:nil != nil && CanBeLinuxRootFS (part_fs) && part_fs_name != nil) {
		    fs = sformat(
			_("%1 (%2)"),
			i[`fstype]:"", part_fs_name
		    );
		} else {
		    fs = i[`fstype]:i[`fs]:"";
		}
		// Table item (unknown file system)
		if (fs == "") fs = _("Unknown");
		
		string label = i[`label]:"";

		part_list = add (part_list,
		    `item (`id (partition),
			system, partition, arch, fs, label
		    )
		);
	    }
	});
	return part_list;
}

// This dialog comes in three different flavors: `update_dialog,
// `update_popup and `boot_popup, `update_dialog_proposal
symbol RootPartitionDialog (symbol flavor) {

    list<term> partition_list = make_partition_list (
	RootPart::showAllPartitions);


    string title = "";
    string label = "";
    string help_text = "";

    if (flavor == `boot_popup)
    {
	// label for selection of root partition (for boot)
	label = _("Partition or System to Boot:");

	// help text for root partition dialog (for boot)
	help_text = _("<p>
Select the partition or system to boot.
</p>
");
    }
    else
    {
	// label for selection of root partition (for update)
	label = _("Partition or System to Update:");

	// help text for root partition dialog (for update)
	help_text = _("<p>
Select the partition or system to update.
</p>
");

	if (flavor == `update_dialog || flavor == `update_dialog_proposal)
	{
	    // headline for dialog "Select for update"
	    title = _("Select for Update");
	}
    }

    // help text for root partition dialog (general part)
    help_text = help_text + _("<p>
<b>Show All Partitions</b> expands the list to a
general overview of your system's partitions.
</p>
");

    term contents = `HBox (
	`HSpacing (2),
	`VBox (
	    `VSpacing (1),
	    `HSpacing( 40 ),	// force minimum width
	    `Left (`Label (label)),
	    `Table (`id (`partition),
		`opt(`hstretch),
			 // table header
		`header (
		    _("System"),
		    // table header item
		    _("Partition"),
		    // table header item
		    _("Architecture"),
		    // table header item
		    _("File System"),
		    // table header item
		    _("Label")
		),
		partition_list),
	    `Left(`CheckBox(`id(`showall), `opt(`notify),
		// check box
		_("&Show All Partitions"), false)),
	    `VSpacing (1)
	),
	`HSpacing (2)
    );


    if (flavor == `update_dialog)
    {
	Wizard::SetContents (title, contents, help_text, true, true);
    }
    else if (flavor == `update_dialog_proposal)
    {
	Wizard::CreateDialog ();
	Wizard::SetContentsButtons (title, contents, help_text,
	    Label::BackButton (), Label::AcceptButton ());
    }
    else
    {
	term buttons = `PushButton (`id(`next), `opt(`default), Label::OKButton());

	if (flavor == `boot_popup)
	{
	    buttons = `HBox (
			     // pushbutton to (rightaway) boot the system selected above
			     `HWeight( 1, `PushButton(`id(`next), `opt(`default), _("&Boot")) ),
			     `HSpacing( 1 ),
			     `HWeight( 1, `PushButton(`id(`cancel), Label::CancelButton() ) )
			     );
	}

	term full = `HBox (
			   `VSpacing( 16 ),		// force dialog height
			   `VBox(
				 `HSpacing( 30 ),	// force help text width
				 `RichText( help_text )
				 ),
			   `HSpacing( 3 ),
			   `VBox(
				 `VSpacing( 1 ),
				 contents,
				 buttons
				 ),
			   `HSpacing( 3 )
			   );

	UI::OpenDialog (full);
    }


    if (size (RootPart::selectedRootPartition) > 0)
	UI::ChangeWidget (`id(`partition), `CurrentItem, RootPart::selectedRootPartition);

    UI::ChangeWidget(`id(`showall), `Value, RootPart::showAllPartitions);


    any ret = nil;

    while (true)
    {
	if (flavor == `update_dialog || flavor == `update_dialog_proposal)
	    ret = Wizard::UserInput ();
	else
	    ret = UI::UserInput ();

	if (ret == `abort && Popup::ConfirmAbort (`painless))
	    break;

	if (ret == `showall)
	{
	    string tmp = (string) UI::QueryWidget (`id(`partition), `CurrentItem);
	    partition_list = make_partition_list ((boolean) UI::QueryWidget (`id(`showall), `Value));
	    UI::ChangeWidget (`id(`partition), `Items, partition_list);
	    if (tmp != nil)
		UI::ChangeWidget (`id(`partition), `CurrentItem, tmp);
	    continue;
	}
	if ((flavor == `update_dialog || flavor == `update_popup
	    || flavor == `update_dialog_proposal)
	    && ret == `next)
	{
	    string selected = (string) UI::QueryWidget (`id(`partition), `CurrentItem);
	    map freshman = RootPart::rootPartitions[selected]:$[];
	    boolean cont = true;
	    y2milestone ("Selected root partition: %1 %2",
		selected, freshman);
	    if (freshman[`name]:"unknown" == "unknown")
	    {
		cont = Popup::ContinueCancel (
// continue-cancel popup
_("No installed system that can be upgraded with this product was found
on the selected partition."));
	    }
	    else if (freshman[`arch]:"" != RootPart::GetDistroArch ())
	    {
		cont = Popup::ContinueCancel (
// continue-cancel popup
_("The architecture of the system installed in the selected partition
is different than the one of this product."));

	    }
	    if (! cont)
		ret = nil;
	}
	if (ret == `next)
	{
	    RootPart::selectedRootPartition = (string) UI::QueryWidget (`id(`partition), `CurrentItem);
	    RootPart::showAllPartitions = (boolean) UI::QueryWidget (`id(`showall), `Value);

	    if (flavor == `update_dialog)
	    {
		RootPart::targetOk = RootPart::mount_target ();

		if (!RootPart::targetOk)
		{
		    // error report
		    Report::Error (_("Failed to mount target system"));
		    Update::Detach ();
		    RootPart::UnmountPartitions (false);
		    continue;
		}
	    }
	    break;
	}
	if (ret == `cancel || ret == `back || ret == `next)
	    break;
    }

    if (flavor != `update_dialog)
	UI::CloseDialog ();

    return (symbol)ret;
}

} // EOF
