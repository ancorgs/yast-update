/**
 * Module: 		inst_sw_update.ycp
 *
 * Authors:		Stefan Schubert <schubi@suse.de>
 *
 * Purpose:
 * Displays software selection screen of update.
 *
 *
 * $Id$
 */

{
    textdomain "update";

    import "Arch";
    import "Mode";
    import "Installation";
    import "Wizard";
    import "Packages";
    import "Update";
    import "Kernel";

    boolean retval = false;

    boolean yast2Found = false;

    if ( !Update::updateEvaluated )
    {
	Update::updateEvaluated = true;

	UI::OpenDialog(`opt(`decorated ),`Label(_("Evaluating update packages. One moment please...")));

	// [ integer affected, integer unknown ]
	list brokenPackages = Pkg::PkgUpdateAll (Update::deleteOldPackages);

	// store all those packages to provide the list for inst_sw_single.ycp
	Update::affected_count = brokenPackages[0]:0;
	Update::unknown_count = brokenPackages[1]:0;

	y2milestone ("Update::affected_count %1, unknown_count %2", Update::affected_count, Update::unknown_count);

	map update_inf = Pkg::TargetUpdateInf (Installation::destdir + "/var/lib/YaST/update.inf");
	if (update_inf == nil)
	{
	    list products = Pkg::TargetProducts();
	    Update::installedName = products[0,"distname"]:"?";
	    Update::installedVersion = products[0,"distversion"]:"";
	}
	else
	{
	    Update::installedName = update_inf["distname"]:"?";
	    Update::installedVersion = update_inf["distversion"]:"";
	}

	integer number_of_sources = size (Packages::theSources);
	if (number_of_sources <= 0)
	{
	    y2error ("No source");
	    Update::updateVersion = "?";
	    Update::updateBasePackages = false;
	}
	else
	{
	    map product = Pkg::SourceProduct (Packages::theSources[number_of_sources-1]:0);
	    y2milestone ("First source product %1", product);
	    if (product == nil) product = $[];
	    Update::updateVersion = product["product"]:"?";
	    string product_package = product["requires"]:"";
	    boolean requires_selected = Pkg::IsSelected (product_package);
	    if (requires_selected == nil) requires_selected = false;
	    if (!requires_selected
		&& !Pkg::IsProvided (product_package))
	    {
		Pkg::PkgInstall (product_package);
		requires_selected = true;
	    }
	    Update::updateBasePackages = requires_selected;
	}

	// do not delete "aps" if it is in use
	if (SCR::Execute(.target.bash, sformat("grep -q apsfilter %1/etc/printcap", Installation::destdir)) == 0)
	{
	    Pkg::PkgInstall ("aps");
	}
		
	// adding vnc package if in vnc update mode
	if ( Mode::vnc )
	{
	    Pkg::PkgInstall ("vnc");
	}

//*************** FIXME #19071
	Pkg::PkgInstall ("grub");
//*************** FIXME #19071

	UI::CloseDialog();

    } // evaluate updatelist


    if ( Mode::test )
    {
	// we have no root-permissions for /var/lib/YaST
	Update::installedName = "SuSE-Linux-full-i386";
	Update::installedVersion = "6.4.0";
    }

    integer automatikUpdate = Update::affected_count;
    integer unknownUpdate = Update::unknown_count;

    // screen title for software selection
    string title = _("Software Update");

    string labelInstalled   = Update::installedName + " " + Update::installedVersion;
    string labelUpdateVersion      = Update::updateVersion;
    string labelUpdateBasePackages = "";

    if ( Update::updateBasePackages )
    {
	labelUpdateBasePackages = _("yes");
    }
    else
    {
	labelUpdateBasePackages = _("no");
    }

    string labelAutomaticUpdate = sformat ("%1", automatikUpdate);	// integer -> string
    string labelUnknownUpdate =   sformat ("%1", unknownUpdate);	// integer -> string

    // Build and show dialog

    term contents = `HVSquash(
			      `VBox(`VBox(
					  // update dialogue, label for old version field
					  `Left(`Label( `id(`InstalledVersion), _("Installed version:") )),
					  `HWeight( 80,
						    `Left(`Label( `id(`labelInstalled),
								  `opt(`outputField,`hstretch ),
								  labelInstalled ))
						    ),
					  // update dialogue, label for new version field
					  `Left(`Label( `id(`UpdateVersion),_("Update version:") )),
					  `HWeight( 80,
						    `Left(`Label( `id(`labelUpdateVersion),
							`opt(`outputField,`hstretch),
								  labelUpdateVersion ))
						    ),
					  // update dialogue, yes/no label
					  `Left(`Label( `id(`UpdateBasePackages),_("Update base packages:") )),
					  `HWeight( 80,
						    `Left(`Label( `id(`labelUpdateBasePackages),
								  `opt(`outputField,`hstretch),
								  labelUpdateBasePackages ))
						    ),
					  // update dialogue, total count of affected packages
					  `Left(`Label( `id(`AutomaticUpdate),_("Packages to update:") )),
					  `HWeight( 80,
						    `Left(`Label( `id(`labelAutomaticUpdate),
								  `opt(`outputField,`hstretch),
								  labelAutomaticUpdate ))
						    ),
					  // update dialogue, number of packages to be installed but which
					  // are not the original ones (not from a SuSE system)
					  `Left(`Label( `id(`UnknownUpdate),_("Packages to check manually:") )),
					  `HWeight( 80,
						    `Left(`Label( `id(`labelUnknownUpdate),
								  `opt(`outputField,`hstretch ),
								  labelUnknownUpdate ))
						    )
					  ),
				    `VSpacing(),
				    // Push button that will pop up the detailed
				    // software selection
				    `PushButton( `id(`details),  _("&Detailed selection...")
						 )
				    )
			     );


    // explain choosable system configurations
    // but beware: some of the text in <b>'s, e.g. Default comes from the index file,
    // translations must be consistent with po/index/index.??.po
    // help part 1

    string helptext = _("<p>
The update process recognizes packages that must be updated.
For some packages, the user must decide (with the button \"Detailed selection\")
if the package should be updated.
</p>
");

    //****************************************************************
    // Checking depencenies
    // if adding more packages via selections (Update::onlyUpdateSelected == false)
    // prefer already installed packages in conflicts

    boolean ok = Pkg::PkgSolve (!Update::onlyUpdateSelected);
    
    //****************************************************************
    
    // Checking disk-space
    SpaceCalculation::ShowPartitionWarning();
    
    Wizard::SetContents(title, contents, helptext, Args(0),Args(1));
  
    any ret = nil;
    boolean seen_details = false;

    while (true)
    {
	ret = UI::UserInput();

	if (ret == `cancel || ret == `back ) break;

	if ( ret == `abort && CallFunction(`inst_confirm_abort(`painless) ) )
	    return `abort;

	if ( ret == `details )
	{
	    seen_details = true;
	    if ( Update::unknown_count > 0 )
	    {
		UI::OpenDialog (`opt(`defaultsize), `PackageSelector (`id(`selector), `opt(`updateMode ))); 
	    }
	    else
	    {
		UI::OpenDialog (`opt(`defaultsize), `PackageSelector (`id(`selector))); 
	    }
	    ret = UI::RunPkgSelection (`id(`selector));
	    UI::CloseDialog();

	    ret = `again;		// stay in loop
	}

	if ( ret == `next )
	{
	    if (Update::affected_count <= 0 )
	    {
		UI::MessagePopup(_("There is nothing to update."));
// FIXME		ret = `again;
// FIXME		break;
	    }
	    if (!seen_details
		&& Update::unknown_count > 0 )
	    {
		string message =
			_("There are packages that need a manual decision
whether to perform the update.
We recommend updating these packages as well,
but you should have a look at it.

Would you like to browse though these packages?
");

		if ( UI::YesNoPopup(message) )
		{
		    UI::OpenDialog (`opt(`defaultsize), `PackageSelector (`id(`selector), `opt(`updateMode ))); 
		    ret = UI::RunPkgSelection (`id(`selector));
		    UI::CloseDialog();

		    if ( ret == `cancel )
			ret = `again;
		    break;
		}
	    }

	    // FIXME
	    if (false)
	    {
		UI::MessagePopup( _("Base packages can only be updated
if the system has been booted from CD.
Boot from CD.
") );
		ret = `again;
	    }
	    else
	    {
		break;
	    }
	}
    }

    y2debug( "inst_sw_update return: %1", ret );

    return ret;
}
