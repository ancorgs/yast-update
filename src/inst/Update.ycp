S/**
 * Module:		Update.ycp
 *
 * Authors:		Anas Nashif (nashif@suse.de)
 *
 * Purpose:		Update module
 *
 *
 * $Id$
 */
{
    module "Update";

    global integer affected_count = 0;
    // number of packages affected by update

    global integer unknown_count = 0;
    // number of packages unknown by update (non-suse packages)

    global boolean kernel_affected = false;
    // if the kernel was affected in _normal_ update mode

    global boolean deleteOldPackages = false;
    // Flag is set true if the user decides to delete unmaintained packages

    global integer last_runlevel = -1;

    global string selectedRootPartition = "";
    // selected rootpartition for the update

    global map validRootPartitions = $[];
    // available rootpartitions (key) and SuSE versions (value)

    global boolean onlyUpdateSelected = false;
    // Only an update, NOT an upgrade

    global boolean updateEvaluated = false;
    // Flag if the updatelist has already evaluated

    global string installedName = "";
    // Name of the targetsystem

    global string installedVersion = "";
    // Version of the targetsystem

    global string updateVersion = "";
    // Version of the source medium

    global boolean updateBasePackages = false;
    // Flag, if the basesystem have to be installed

    global integer packagesInstalled = 0;
    // counter for installed packages

    /**
     * List of mounted partitions, activated swap partitions and loop devices.
     * Used for reversing action if mode is changed from update to new
     * installation or if root directory for update is changed. Each item is
     * list [string value, string type], where type is "mount", "swap", "loop",
     * value is path to mounted directory, swap partition name or loop device
     * name according to type value.
     */
    list activated = [];

    /*-----------------------------------------------------------------------
     * GLOBAL FUNCTIONS
     *-----------------------------------------------------------------------*/

    /**
     * Unmount all mounted partitions, deactivate swaps, detach loopback
     * devices. Uses list activated to make actions in reverse order.
     * @return void
     */
    global define void UnmountPartitions() ``{
	 y2milestone("Unmount partitions: %1", activated);

	 foreach(list info, activated, ``{
		string file = info[0]:"";
		string type = info[1]:"";

		if (file != "" && type != "")
		{
		    if (type == "mount")
		    {
			if (SCR::Execute (.target.umount, file) != 0)
			{
			    y2error("Cannot unmount partition %1", file);
			}
		    }
		    else if (type == "swap")
		    {
			if (SCR::Execute (.target.bash, "/sbin/swapoff " + file) != 0)
			{
			    y2error("Cannot deactivate swap %1", file);
			}
		    }
		    else if (type == "loop")
		    {
			if (WFM::Execute(.local.bash, "losetup -d " + file) != 0)
			{
			    y2error("Cannot deactivate loopback device %1", file);
			}
		    }
		}
	    }
	);

        SCR::Write(.lvm.deactivate, "");
	SCR::Write(.md.deactivate, "");

	// clear activated list
	activated = [];
    };

    /**
     * Add information about mounted partition to internal list.
     * @param partinfo partinfo has to be list with exactly two strings, see description of list "activated"
     * @return void
     */
    global define void AddMountedPartition(list partinfo) ``{
	y2debug("Added partition info: %1", partinfo);
	activated = prepend(activated, partinfo);
	y2debug("Total partition info: %1", activated);
    }

}


